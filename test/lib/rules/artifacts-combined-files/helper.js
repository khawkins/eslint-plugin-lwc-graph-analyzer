/*
 * Copyright (c) 2025, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

'use strict';

const { readFileSync } = require('fs');
const { basename, dirname, join, parse, extname } = require('path');
const { Linter } = require('eslint');
const babelParser = require('@babel/eslint-parser');
const lwcGraphAnalyzer = require('../../../../lib/index');
const LwcBundle = require('../../../../lib/lwc-bundle');

/**
 * Creates ESLint configuration for a given rule
 * @param {string} rulename - Name of the rule to configure
 * @returns {Object} ESLint configuration
 */
function createLinterConfig(rulename) {
    return {
        parser: '@babel/eslint-parser',
        parserOptions: {
            requireConfigFile: false,
            sourceType: 'module',
            babelOptions: {
                parserOpts: {
                    plugins: [['decorators', { decoratorsBeforeExport: false }]]
                }
            }
        },
        root: true,
        plugins: ['@salesforce/lwc-graph-analyzer'],
        processor: '@salesforce/lwc-graph-analyzer/bundleAnalyzer',
        rules: {
            [rulename]: 'error'
        }
    };
}

/**
 * Creates and configures an ESLint linter instance
 * @param {string} rulename - Name of the rule to configure
 * @returns {Object} Configured ESLint linter
 */
function createLinter(rulename) {
    const linter = new Linter();
    linter.defineParser('@babel/eslint-parser', babelParser);
    linter.defineRule(rulename, lwcGraphAnalyzer.rules[rulename]);
    return linter;
}

/**
 * Runs ESLint on a bundle using file-based bundle setup
 * @param {string} rulePath - Path to the rule being tested
 * @param {string} target - Target file to lint
 * @returns {Array} ESLint messages
 */
function lintBundle(rulePath, target) {
    const rulename = parse(basename(rulePath)).name;
    const config = createLinterConfig(rulename);
    const linter = createLinter(rulename);
    const testPath = join(dirname(rulePath), target);
    const srcCode = readFileSync(testPath).toString();

    return linter.verify(srcCode, config, {
        filename: testPath,
        preprocess: lwcGraphAnalyzer.processors.bundleAnalyzer.preprocess,
        postprocess: lwcGraphAnalyzer.processors.bundleAnalyzer.postprocess,
        filterCodeBlock: function () {
            // This predicate function tells linter to skip processing
            // generated code blocks. Code blocks are virtual files
            // generated by eslint when linting mixed file types, like
            // js & html or js & markdown.
            return true;
        }
    });
}

/**
 * Runs ESLint on a bundle using programmatic bundle setup
 * @param {string} rulePath - Path to the rule being tested
 * @param {string} target - Target file to lint
 * @returns {Array} ESLint messages
 */
function lintProgrammaticBundle(rulePath, target) {
    const rulename = parse(basename(rulePath)).name;
    const config = createLinterConfig(rulename);
    const linter = createLinter(rulename);
    const testPath = join(dirname(rulePath), target);
    const srcCode = readFileSync(testPath).toString();

    // Create and set the bundle before linting
    const bundle = LwcBundle.lwcBundleFromFilesystem(srcCode, testPath, extname(testPath));
    lwcGraphAnalyzer.lwcBundle = bundle;

    return linter.verify(srcCode, config, {
        filename: testPath,
        preprocess: lwcGraphAnalyzer.processors.bundleAnalyzer.preprocess,
        postprocess: lwcGraphAnalyzer.processors.bundleAnalyzer.postprocess,
        filterCodeBlock: function () {
            // This predicate function tells linter to skip processing
            // generated code blocks. Code blocks are virtual files
            // generated by eslint when linting mixed file types, like
            // js & html or js & markdown.
            return true;
        }
    });
}

module.exports = {
    lintBundle,
    lintProgrammaticBundle
};
