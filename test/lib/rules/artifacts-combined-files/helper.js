/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

'use strict';

const { Linter } = require('eslint');
const { dirname, join, basename, parse } = require('path');
const { readFileSync } = require('fs');
const parser = require('@babel/eslint-parser');
const graphAnalyzer = require('../../../../lib/index');
const allRules = require('../../../../lib/index');

function lintBundle(rulePath, target) {
    const rulename = parse(basename(rulePath)).name;
    const config = {
        parser: '@babel/eslint-parser',
        parserOptions: {
            ecmaVersion: 'latest',
            requireConfigFile: false,
            sourceType: 'module',
            babelOptions: {
                parserOpts: {
                    plugins: [['decorators', { decoratorsBeforeExport: false }]]
                }
            }
        },
        root: true,
        plugins: ['@salesforce/lwc-graph-analyzer'],
        processor: '@salesforce/lwc-graph-analyzer/bundleAnalyzer',
        rules: {}
    };
    config.rules[rulename] = 'error';

    const rule = allRules.rules[rulename];

    const linter = new Linter();
    linter.defineParser('@babel/eslint-parser', parser);
    linter.defineRule(rulename, rule);

    const testPath = join(dirname(rulePath), target);
    const srcCode = readFileSync(testPath).toString();

    const messages = linter.verify(srcCode, config, {
        filename: testPath,
        preprocess: graphAnalyzer.processors.bundleAnalyzer.preprocess,
        filterCodeBlock: function () {
            // This predicate function tells linter to skip processing
            // generated code blocks. Code blocks are virtual files
            // generated by eslint when linting mixed file types, like
            // js & html or js & markdown.
            return true;
        }
    });

    return messages;
}

module.exports = {
    lintBundle
};
